#include <iostream>
#include "../include/bittorrent/bencode.hpp"

/* auto parse_torrent(const std::string &path, size_t &pos) -> json
{
    // std::streampos size;
    std::streampos size;
    char *buffer;

    std::ifstream file(path, std::ios::in | std::ios::binary | std::ios::ate);
    json torrent_info;

    if (file.is_open())
    {

        size = file.tellg();
        int buff_size = file.tellg();
        buffer = new char[size];
        file.seekg(0, std::ios::beg);
        file.read(buffer, size);

        json torrent_info;
        std::string torrent_info_str(buffer, buff_size);

        try
        {
            size_t position = 0;
            torrent_info = decode_bencoded_value(torrent_info_str, position);
        }
        catch (...)
        {

            std::cout << "Exception in parse_torrent(): " << std::endl;
        }

        delete[] buffer;
        file.close();

        return torrent_info;
    }
    else
    {
        throw std::runtime_error("Unable to open file: " + path);
    }
} */

/* auto get_info_string(const std::string &path) -> std::string
{

    // Parse and store the string starting with "info"

    // std::streampos size;
    std::streampos size;
    char *buffer;

    std::ifstream file(path, std::ios::in | std::ios::binary | std::ios::ate);
    json torrent_info;

    if (file.is_open())
    {

        size = file.tellg();
        int buff_size = file.tellg();
        buffer = new char[size];
        file.seekg(0, std::ios::beg);
        file.read(buffer, size);

        json torrent_info;
        std::string torrent_info_str(buffer, buff_size);

        delete[] buffer;
        file.close();

        return torrent_info_str;
    }
    else
    {
        throw std::runtime_error("Unable to open file: " + path);
    }
} */

/**
 * Decoding SHA-1 Values:
 *
 * Info Hash & Pieces Hash
 *
 * Info Hash: Unique Identifier derived from the information contained in the "info" dictionary
 * Hash Gen:  Generated by computing the SHA-1 hash of this dictionary to identify the "torrent" file itself
 *
 * Hash Generation:
 * Serialize the "info" dictionary from the torrent's bencoded data structure and apply the SHA-1 hash function
 * Result: A 20-byte value (represented as a 40-character Hex-String)
 *
 *
 * piece length: number of bytes in each piece (int)
 * pieces:       a string consisting of the concatenation of all 20-byte SHA-1 hash values, one per piece (byte string i.e. not urlencoded)
 *
 * How do we parse the raw bytes into pieces string?
 * From sample_torrent we get:
 * Total Size :                                                        92063 Bytes  = 92.06 kB (Total Size of the File)
 * SHA-1 Pieces (20 Bytes Each):     Bencoded: pieces60: --> 60 Bytes     60 Bytes / 20 Bytes = 3 SHA-1 Pieces
 * Piece Size :                                                        92603 Bytes / 3 (Pieces Count) = 32.00 KiB
 *
 *
 * Parsing the "piece60":"SHA-1 Hash Values"
 * Each Piece Contains: 20 Bytes and Piece Count : 3
 * Process each piece incrementally by processing 20-Bytes subsequently and converting each piece into Hexadecimal Format
 *
 *
 *
 */

// SHA-1 Custom Implementation
// Left rotate function using trailing return type
/* auto leftRotate(unsigned int value, int bits) -> unsigned int
{
    return (value << bits) | (value >> (32 - bits));
}

// SHA-1 Hashing Function using trailing return type
auto sha1(const std::string &input) -> std::string
{
    // Initial hash values (SHA-1 constants)
    unsigned int h0 = 0x67452301;
    unsigned int h1 = 0xEFCDAB89;
    unsigned int h2 = 0x98BADCFE;
    unsigned int h3 = 0x10325476;
    unsigned int h4 = 0xC3D2E1F0;

    // Pre-processing: Padding the input
    std::vector<unsigned char> paddedInput(input.begin(), input.end());
    paddedInput.push_back(0x80); // Append a single '1' bit (0x80)

    // Pad with zeros to make the length congruent to 56 mod 64
    while ((paddedInput.size() * 8) % 512 != 448)
    {
        paddedInput.push_back(0x00);
    }

    // Append original length in bits to the message (big-endian)
    uint64_t originalBitLength = static_cast<uint64_t>(input.size()) * 8;
    for (int i = 7; i >= 0; --i)
    {
        paddedInput.push_back(static_cast<unsigned char>((originalBitLength >> (i * 8)) & 0xFF));
    }

    // Process the message in 512-bit chunks (64 bytes)
    for (size_t i = 0; i < paddedInput.size(); i += 64)
    {
        unsigned int w[80] = {0};

        // Break chunk into sixteen 32-bit big-endian words w[i]
        for (int j = 0; j < 16; ++j)
        {
            w[j] = (paddedInput[i + j * 4] << 24) |
                   (paddedInput[i + j * 4 + 1] << 16) |
                   (paddedInput[i + j * 4 + 2] << 8) |
                   (paddedInput[i + j * 4 + 3]);
        }

        // Extend the sixteen 32-bit words into eighty 32-bit words
        for (int j = 16; j < 80; ++j)
        {
            w[j] = leftRotate(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }

        // Initialize hash value for this chunk
        unsigned int a = h0;
        unsigned int b = h1;
        unsigned int c = h2;
        unsigned int d = h3;
        unsigned int e = h4;

        // Main loop of the SHA-1 algorithm
        for (int j = 0; j < 80; ++j)
        {
            unsigned int f, k;
            if (j < 20)
            {
                f = (b & c) | (~b & d);
                k = 0x5A827999;
            }
            else if (j < 40)
            {
                f = b ^ c ^ d;
                k = 0x6ED9EBA1;
            }
            else if (j < 60)
            {
                f = (b & c) | (b & d) | (c & d);
                k = 0x8F1BBCDC;
            }
            else
            {
                f = b ^ c ^ d;
                k = 0xCA62C1D6;
            }

            unsigned int temp = leftRotate(a, 5) + f + e + k + w[j];
            e = d;
            d = c;
            c = leftRotate(b, 30);
            b = a;
            a = temp;
        }

        // Add this chunk's hash to the result
        h0 += a;
        h1 += b;
        h2 += c;
        h3 += d;
        h4 += e;
    }

    // Produce the final hash value (big-endian) as a hex string
    std::ostringstream result;
    result << std::hex << std::setfill('0') << std::setw(8) << h0
           << std::setw(8) << h1
           << std::setw(8) << h2
           << std::setw(8) << h3
           << std::setw(8) << h4;

    return result.str();
}

auto get_info(const std::string &path, size_t &pos) -> std::vector<std::string>
{

    // Initiate the Sub-Routine to copy the info part of the string
    auto torrent_meta_string = get_info_string(path);
    std::cout << torrent_meta_string << std::endl;
    auto info_string = torrent_meta_string.substr(torrent_meta_string.find("info"), std::string::npos);
    auto info_hash = sha1("torrent_meta_string");

    json torrent_table = parse_torrent(path, pos);
    auto torrent_info = torrent_table.find("info");

    // Generate Info Hash

    // Retrieve Values for Keys:
    auto tracker_it = torrent_table.find("announce"); // Tracker Link
    auto length_it = torrent_info->find("length");    // Length
    auto pieces_it = torrent_info->find("pieces");    // Pieces

    if (tracker_it != torrent_table.end() && length_it != torrent_info->end() && pieces_it != torrent_info->end())
    {
        json link_j = tracker_it.value();
        json length_j = length_it.value();
        json pieces_j = pieces_it.value();

        std::string link = link_j.dump();
        std::string length = length_j.dump();
        std::string pieces = pieces_j.dump();

        std::vector<std::string> vector_info;
        vector_info.push_back(link.substr(link.find_first_of("\"") + 1, link.find_last_of("\"") - 1));
        vector_info.push_back(length);
        // vector_info.push_back(pieces.substr(pieces.find_first_of("\"") + 1, pieces.find_last_of("\"") - 1));
        vector_info.push_back(info_hash);

        return vector_info;

        // std::string link = link_j.dump();
        // std::string length = length_j.dump();

        // std::vector<std::string> output = {link.substr(1, link.length() - 2), length};
        // return output;
    }

    return {};
}
 */
/* auto info_torrent(const std::string &path, size_t &pos) -> std::pair<json, json>
{
    json::object_t torrent_info = parse_torrent(path, pos);

    json::string_t key_url = "announce";
    json::string_t key_info = "info";
    json::string_t key_size = "piece length";

    json::string_t url = torrent_info.find(key_url)->second;
    json::object_t info_map = torrent_info.find(key_info)->second;
    json::string_t piece = info_map.find(key_size)->second;

    return std::make_pair(json(url), json(piece));
} */

int main(int argc, char *argv[])
{
    // Flush after every std::cout / std::cerr
    std::cout << std::unitbuf;
    std::cerr << std::unitbuf;

    if (argc < 2)
    {
        std::cerr << "Usage: " << argv[0] << " decode <encoded_value>" << std::endl;
        return 1;
    }

    std::string command = argv[1];

    if (command == "decode")
    {
        if (argc < 3)
        {
            std::cerr << "Usage: " << argv[0] << " decode <encoded_value>" << std::endl;
            return 1;
        }

        std::string encoded_value = argv[2];
        size_t position = 0;
        auto decoded_value = Bencode::decodeBencode(encoded_value, position);
        std::cout << decoded_value.dump() << std::endl;
    }
    else if (command == "info")
    {
        if (argc < 3)
        {
            std::cerr << "Usage: " << argv[0] << " info path/to/file.torrent" << std::endl;
        }

        std::string path = argv[2];
        size_t pos = 0;

        std::vector<std::string> decoded_torrent_info = Bencode::infoTorrent(path, pos);

        std::cout << "Tracker URL: " + decoded_torrent_info[0] + "\n";
        std::cout << "Length: " + decoded_torrent_info[1] + "\n";
        std::cout << "Info Hash: " + decoded_torrent_info[2] << std::endl;
        // std::string output = decoded_torrent_info.dump();
        //     std::cout << output.substr(1, output.size() - 2) << std::endl;
        // std::cout << std::to_string(decoded_torrent_info) << std::endl;
        // std::cout << decoded_torrent_info.dump() << std::endl;

        // std::pair<nlohmann::json, nlohmann::json> tor(Bencode::parseTorrent(path, pos));
        // std::cout << "Tracker URL: " << tor.first.dump() << "\n";
        // std::cout << "Piece Length: " << tor.second.dump() << std::endl;
    }
    else
    {
        std::cerr << "unknown command: " << command << std::endl;
        return 1;
    }

    return 0;
}
